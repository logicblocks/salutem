<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Getting Started</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Salutem</span> <span class="project-version">0.1.2-RC3</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="getting-started.html"><div class="inner"><span>Getting Started</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>salutem</span></div></div></li><li class="depth-2"><a href="salutem.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="salutem.core.checks.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>checks</span></div></a></li><li class="depth-3 branch"><a href="salutem.core.maintenance.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>maintenance</span></div></a></li><li class="depth-3 branch"><a href="salutem.core.registry.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>registry</span></div></a></li><li class="depth-3 branch"><a href="salutem.core.results.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>results</span></div></a></li><li class="depth-3"><a href="salutem.core.time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>time</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#getting-started" name="getting-started"></a>Getting Started</h1>
<p><code>salutem</code> is a system for defining and maintaining a collection of health checks with support for:</p>
<ul>
  <li>both realtime and background checks,</li>
  <li>a registry for storing, finding and resolving checks, and</li>
  <li>an asynchronous maintenance system for ensuring that the results of checks are  kept up-to-date according to their definition, notifying on the results of  those checks as needed.</li>
</ul>
<p><code>salutem</code> is somewhat inspired by <a href="https://github.com/dropwizard/dropwizard-health">dropwizard-health</a> which may provide additional insight into its design.</p>
<h2><a href="#contents" name="contents"></a>Contents</h2>
<ul>
  <li><a href="#installation">Installation</a></li>
  <li><a href="#definitions">Definitions</a></li>
  <li><a href="#creating-checks">Creating checks</a>
    <ul>
      <li><a href="#check-functions">Check functions</a></li>
      <li><a href="#producing-results">Producing results</a></li>
      <li><a href="#creating-a-realtime-check">Creating a realtime check</a></li>
      <li><a href="#creating-a-background-check">Creating a background check</a></li>
    </ul>
  </li>
  <li><a href="#evaluating-checks">Evaluating checks</a>
    <ul>
      <li><a href="#synchronously-evaluating-a-check">Synchronously evaluating a check</a></li>
      <li><a href="#asynchronously-evaluating-a-check">Asynchronously evaluating a check</a></li>
      <li><a href="#working-with-results">Checking if results are out-of-date</a></li>
    </ul>
  </li>
  <li><a href="#managing-checks-using-a-registry">Managing checks using a registry</a>
    <ul>
      <li><a href="#creating-and-populating-a-registry">Creating and populating a registry</a></li>
      <li><a href="#querying-a-registry">Querying a registry</a></li>
      <li><a href="#resolving-checks-in-a-registry">Resolving checks in a registry</a></li>
    </ul>
  </li>
  <li><a href="#the-maintenance-pipeline">The maintenance pipeline</a>
    <ul>
      <li><a href="#starting-the-maintenance-pipeline">Starting the maintenance pipeline</a></li>
      <li><a href="#stopping-the-maintenance-pipeline">Stopping the maintenance pipeline</a></li>
      <li><a href="#customising-the-maintenance-pipeline">Customising the maintenance pipeline</a></li>
      <li><a href="#enabling-logging">Enabling logging</a></li>
    </ul>
  </li>
</ul>
<h2><a href="#installation" name="installation"></a>Installation</h2>
<p>Add the following to your <code>project.clj</code> file:</p>
<pre><code class="clojure">[io.logicblocks/salutem.core "0.1.1"]
</code></pre>
<h2><a href="#definitions" name="definitions"></a>Definitions</h2>
<p><code>salutem</code> introduces some domain terminology which we use throughout this guide. The following domain model and definitions detail the domain.</p>
<img src="images/domain-model.png" alt="Domain Model" style="width: 100%; max-width: 680px;" />
<ul>
  <li>A <strong>Check</strong> is identified by its name and includes a function that performs  the corresponding health check. Checks have a timeout such that if the check  function takes too long, it can be aborted.</li>
  <li>Checks produce <strong>Results</strong> when they are <em>evaluated</em>, indicating the outcome  of the check. Results have a status, with built-in support for <em>healthy</em> and  <em>unhealthy</em> results. Results also keep track of the instant at which  evaluation occurred. Results can also include arbitrary extra data for storing  other required health check information.</li>
  <li>A <strong>Registry</strong> stores a collection of Checks along with any previously  generated Results that should be cached.</li>
  <li>A <strong>RegistryStore</strong> is an Atom containing a Registry, used in some places  where rather than a Registry, a shared reference to a Registry is required.</li>
  <li>Checks within a Registry can be <em>resolved</em> to a Result, which either retrieves  a cached result or evaluates the check if it is realtime or if there is no  available result.</li>
  <li>There are currently two types of checks supported, <em>RealtimeChecks</em> and  <em>BackgroundChecks</em>.</li>
  <li>A <strong>RealtimeCheck</strong> is evaluated every time it is resolved such that cached  Results will never be returned.</li>
  <li>A <strong>BackgroundCheck</strong> is intended to be evaluated in the background  periodically such that a cached result is returned whenever the Check is  resolved.</li>
</ul>
<h2><a href="#creating-checks" name="creating-checks"></a>Creating checks</h2>
<p>Checks are created with a name, a check function and some additional and optional configuration options depending on the type of check.</p>
<h3><a href="#check-functions" name="check-functions"></a>Check functions</h3>
<p>A check function is an arity-2 function, taking an arbitrary context map and a callback function:</p>
<pre><code class="clojure">(fn [context callback-fn]
  ...)
</code></pre>
<p>All check functions must be non-blocking and must use the provided callback function to communicate the result of their evaluation back to <code>salutem</code>. For example, if you are health checking an HTTP endpoint using a non-blocking HTTP client such as <code>http-kit</code>, the check function might look like the following:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])
(require '[org.httpkit.client :as http])

(fn [context callback-fn]
  (let [url (:url context)]
    (http/get url
      (fn [{:keys [status]}]
        (callback-fn
          (if (&lt;= 200 status 399)
            (salutem/healthy)
            (salutem/unhealthy)))))))
</code></pre>
<p>If your health check logic is blocking, be sure to use a future within your check function to convert the check function to a non-blocking operation. For example, if you have a database driver which only supports blocking operations, the check function might look like the following:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])
(require '[clojure.java.jdbc :as jdbc])

(fn [context callback-fn]
  (future
    (try
      (let [handle (get-in context [:database :handle])
            result (jdbc/query handle ["SHOW SERVER_VERSION;"])]
        (callback-fn (salutem/healthy {:version (:server_version result)})))
      (catch Exception e
        (callback-fn (salutem/unhealthy {:exception e}))))))
</code></pre>
<p>Check functions should also implement some form of timeout on calls that could block for a long time. If using a <a href="#starting-a-maintenance-pipeline">maintenance pipeline</a>, dependent on the type of the check, a check function could be called every interval which could result in resource exhaustion if the check function does not time out quickly enough. It may also make sense to implement some form of circuit breaker within the check function, potentially with exponential backoff. This is currently left up to the implementer of the check function but may be incorporated into <code>salutem</code> in the future.</p>
<h3><a href="#producing-results" name="producing-results"></a>Producing results</h3>
<p>You’ll notice in the check functions defined <a href="#check-functions">above</a>, we used <a href="salutem.core.html#var-healthy">salutem.core/healthy</a> and <a href="salutem.core.html#var-unhealthy">salutem.core/unhealthy</a> to produce healthy and unhealthy results respectively. Whilst it is convenient to have these functions, there’s nothing inherently special about the results generated, except that they have <code>:healthy</code> and <code>:unhealthy</code> statuses. Nothing in <code>salutem</code> depends on these statuses and in fact, any status can be used.</p>
<p>If, for example, you need a status to represent that a dependency is in the process of starting up, you can create such a result using <a href="salutem.core.html#var-result">salutem.core/result</a> directly:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])

(salutem/result :starting-up
  {:progress "Connecting flanges"})
</code></pre>
<p>All of <a href="salutem.core.html#var-healthy">salutem.core/healthy</a>, <a href="salutem.core.html#var-unhealthy">salutem.core/unhealthy</a> and <a href="salutem.core.html#var-result">salutem.core/result</a> keep track of the instant at which evaluation occurred which by default is the instant at which the result was created. To set a specific instant for when evaluation occurred:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])
(require '[tick.alpha.api :as time])

(salutem/healthy
  {:evaluated-at (time/- (time/now) (time/new-duration 20 :minutes))})
(salutem/unhealthy
  {:evaluated-at (time/- (time/now) (time/new-duration 20 :minutes))})
(salutem/result :starting-up
  {:evaluated-at (time/- (time/now) (time/new-duration 20 :minutes))})
</code></pre>
<h3><a href="#creating-a-realtime-check" name="creating-a-realtime-check"></a>Creating a realtime check</h3>
<p>Given an HTTP endpoint check function factory such as the following:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])
(require '[org.httpkit.client :as http])

(defn http-endpoint-check-fn [url]
  (fn [_ callback-fn]
    (http/get url
      (fn [{:keys [status]}]
        (callback-fn
          (if (&lt;= 200 status 399)
            (salutem/healthy)
            (salutem/unhealthy)))))))
</code></pre>
<p>a realtime check of a hypothetical external user profile service could be created using the following:</p>
<pre><code class="clojure">(defn user-profile-service-check
  [configuration]
  (let [url (get-in configuration [:services :user-profile :ping-url])]
    (salutem/realtime-check
      :services/user-profile
      (http-endpoint-check-fn url))))
</code></pre>
<p><a href="salutem.core.html#var-realtime-check">salutem.core/realtime-check</a> additionally supports a <code>:timeout</code> option which defines the amount of time to wait on a result before considering the health check evaluation failed. By default, this is 10 seconds. To override the timeout:</p>
<pre><code class="clojure">(defn user-profile-service-check
  [configuration]
  (let [url (get-in configuration [:services :user-profile :ping-url])]
    (salutem/realtime-check
      :services/user-profile
      (http-endpoint-check-fn url)
      {:timeout (salutem/duration 30 :seconds)})))
</code></pre>
<h3><a href="#creating-a-background-check" name="creating-a-background-check"></a>Creating a background check</h3>
<p>Creating a background check is much the same as creating a realtime check but with one extra option, <code>:time-to-re-evaluation</code>, described below.</p>
<p>Again, given an HTTP endpoint check function factory such as the following:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])
(require '[org.httpkit.client :as http])

(defn http-endpoint-check-fn [url]
  (fn [_ callback-fn]
    (http/get url
      (fn [{:keys [status]}]
        (callback-fn
          (if (&lt;= 200 status 399)
            (salutem/healthy)
            (salutem/unhealthy)))))))
</code></pre>
<p>a background check of a hypothetical external search service could be created using the following:</p>
<pre><code class="clojure">(defn search-service-check
  [configuration]
  (let [url (get-in configuration [:services :search :ping-url])]
    (salutem/background-check
      :services/search
      (http-endpoint-check-fn url))))
</code></pre>
<p>Just as for <a href="salutem.core.html#var-realtime-check">salutem.core/realtime-check</a>, <a href="salutem.core.html#var-background-check">salutem.core/background-check</a> supports a <code>:timeout</code> option which defines the amount of time to wait on a result before considering the health check evaluation failed. By default, this is 10 seconds. To override the timeout:</p>
<pre><code class="clojure">(defn search-service-check
  [configuration]
  (let [url (get-in configuration [:services :search :ping-url])]
    (salutem/background-check
      :services/search
      (http-endpoint-check-fn url)
      {:timeout (salutem/duration 30 :seconds)})))
</code></pre>
<p>Background checks also have a <em>time to re-evaluation</em> which is the amount of time to wait before re-evaluating the check to obtain a fresh result. In between evaluations, whenever the check is resolved, a cached result is returned. <a href="salutem.core.html#var-background-check">salutem.core/background-check</a> allows the time to re-evaluation for a check to be set via the <code>:time-to-re-evaluation</code> option. By default, this is 10 seconds. To override the time to re-evaluation:</p>
<pre><code class="clojure">(defn search-service-check
  [configuration]
  (let [url (get-in configuration [:services :search :ping-url])]
    (salutem/realtime-check
      :services/search
      (http-endpoint-check-fn url)
      {:time-to-re-evaluation (salutem/duration 5 :seconds)})))
</code></pre>
<h2><a href="#evaluating-checks" name="evaluating-checks"></a>Evaluating checks</h2>
<p>Checks are evaluated using <a href="salutem.core.html#var-evaluate">salutem.core/evaluate</a>, with support for both synchronous and asynchronous evaluation.</p>
<h3><a href="#synchronously-evaluating-a-check" name="synchronously-evaluating-a-check"></a>Synchronously evaluating a check</h3>
<p>To evaluate a check synchronously:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])

(def user-profile-service-check
  (salutem/realtime-check :service/user-profile
    (fn [_ callback-fn]
      (callback-fn
        (salutem/healthy {:latency "73ms"})))
    {:timeout (salutem/duration 5 :seconds)}))

(salutem/evaluate user-profile-service-check)
; =&gt; (salutem/healthy {:latency "73ms"})
</code></pre>
<p>If the check requires something from a context map:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])

(def user-profile-service-check
  (salutem/realtime-check :service/user-profile
    (fn [context callback-fn]
      (callback-fn
        (salutem/healthy 
          {:latency "73ms"
           :caller (:caller context)})))
    {:timeout (salutem/duration 5 :seconds)}))

(salutem/evaluate user-profile-service-check
  {:caller :order-service})
; =&gt; (salutem/healthy 
;      {:latency "73ms"
;       :caller :order-service})
</code></pre>
<h3><a href="#asynchronously-evaluating-a-check" name="asynchronously-evaluating-a-check"></a>Asynchronously evaluating a check</h3>
<p>To evaluate a check asynchronously, pass a callback function:</p>
<pre><code class="clojure">(require '[clojure.pprint :as pp])
(require '[salutem.core :as salutem])

(def user-profile-service-check
  (salutem/realtime-check :service/user-profile
    (fn [context callback-fn]
      (future
        (Thread/sleep 300)
        (callback-fn
          (salutem/healthy 
            {:latency "373ms"
             :caller (:caller context)}))))
    {:timeout (salutem/duration 5 :seconds)}))

(salutem/evaluate user-profile-service-check
  {:caller :order-service}
  (fn [result]
    (pp/pprint "Received result.")
    (pp/pprint result)))

(pp/pprint "Waiting on result...")
; Waiting on result...

; some time later

; Received result. 
; {:latency "373ms"
;  :caller :order-service
;  :status :healthy
;  :evaluated-at #time/instant "2021-09-05T01:05:17.070Z"})
</code></pre>
<h3><a href="#working-with-results" name="working-with-results"></a>Working with results</h3>
<p>For healthy and unhealthy results, <code>salutem</code> provides two predicates, <a href="salutem.core.html#var-healthy.3F">salutem.core/healthy?</a> and <a href="salutem.core.html#var-unhealthy.3F">salutem.core/unhealthy?</a> for checking result status.</p>
<p>Additionally, <code>salutem</code> provides the <a href="salutem.core.html#var-outdated.3F">salutem.core/outdated?</a> function to determine if a result of a check is no longer up to date. A result is outdated if:</p>
<ul>
  <li>it is <code>nil</code>;</li>
  <li>it is for a realtime check; or</li>
  <li>it is for a background check and was produced more than the time to  re-evaluation of the check in the past.</li>
</ul>
<h2><a href="#managing-checks-using-a-registry" name="managing-checks-using-a-registry"></a>Managing checks using a registry</h2>
<p>A registry manages a set of checks, allowing storage, lookup and resolution of checks. Registries are immutable and <code>salutem</code> provides manipulation functions for construction and interaction.</p>
<h3><a href="#creating-and-populating-a-registry" name="creating-and-populating-a-registry"></a>Creating and populating a registry</h3>
<p>An empty registry is created using <a href="salutem.core.html#var-empty-registry">salutem.core/empty-registry</a>:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])

(def registry
  (salutem/empty-registry))
</code></pre>
<p>Checks can be added to the registry using <a href="salutem.core.html#var-with-check">salutem.core/with-check</a>:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])

(def registry
  (-&gt; (salutem/empty-registry)
    (salutem/with-check
      (salutem/realtime-check :services/user-profile
        (http-endpoint-check-fn
          "https://user-profile.example.com/ping")
        {:timeout (salutem/duration 5 :seconds)}))
    (salutem/with-check
      (salutem/background-check :services/search
        (http-endpoint-check-fn
          "https://search.example.com/ping")
        {:time-to-re-evaluation (salutem/duration 30 :seconds)}))))
</code></pre>
<p>Whilst mostly for internal use, it’s also possible to cache results in the registry using <a href="salutem.core.html#var-with-cached-result">salutem.core/with-cached-result</a>. The result cache stores a single result per check, overwriting an existing result if present.</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])

(def search-service-check-name :services/user-profile)

(def search-service-check
  (salutem/background-check search-service-check-name
    (http-endpoint-check-fn
      "https://user-profile.example.com/ping")
    {:timeout (salutem/duration 5 :seconds)}))

(def registry
  (-&gt; (salutem/empty-registry)
    (salutem/with-check search-service-check)
    (salutem/with-cached-result search-service-check-name (salutem/healthy))))
</code></pre>
<h3><a href="#querying-a-registry" name="querying-a-registry"></a>Querying a registry</h3>
<p>Let’s say we have the following registry:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])
(require '[tick.alpha.api :as time])

(def user-profile-service-check-name :services/user-profile)
(def search-service-check-name :services/search)

(def user-profile-service-check
  (salutem/realtime-check user-profile-service-check-name
    (http-endpoint-check-fn
      "https://user-profile.example.com/ping")
    {:timeout (salutem/duration 5 :seconds)}))

(def search-service-check
  (salutem/background-check search-service-check-name
    (http-endpoint-check-fn
      "https://search.example.com/ping")
    {:time-to-re-evaluation (salutem/duration 30 :seconds)}))

(def search-service-result
  (salutem/healthy
    {:latency      "82ms"
     :evaluated-at (t/- (t/now) (t/new-duration 15 :seconds))}))

(def registry
  (-&gt; (salutem/empty-registry)
    (with-check user-profile-service-check)
    (with-check search-service-check)
    (with-cached-result search-service-check-name search-service-result)))
</code></pre>
<p>To find a check in the registry:</p>
<pre><code class="clojure">(= search-service-check
  (salutem/find-check registry search-service-check-name))
; =&gt; true
</code></pre>
<p>To find a cached result in the registry:</p>
<pre><code class="clojure">(= search-service-result
  (salutem/find-cached-result registry search-service-check-name))
; =&gt; true
</code></pre>
<p>For a set of all the check names available in the registry:</p>
<pre><code class="clojure">(= #{search-service-check-name user-profile-service-check-name}
  (salutem/check-names registry))
; =&gt; true
</code></pre>
<p>To get all the checks from the registry:</p>
<pre><code class="clojure">(= #{search-service-check user-profile-service-check}
  (salutem/all-checks registry))
; =&gt; true
</code></pre>
<p>To get the checks in the registry that have outdated results:</p>
<pre><code class="clojure">(= #{user-profile-service-check}
  (salutem/outdated-checks registry))
</code></pre>
<h3><a href="#resolving-checks-in-a-registry" name="resolving-checks-in-a-registry"></a>Resolving checks in a registry</h3>
<p>Resolving a check in a registry is the act of obtaining a result for that check. However, it doesn’t necessarily mean that the check will be evaluated. Instead, depending on the type of the check, it may be possible to resolve to a cached result instead of triggering evaluation.</p>
<p>First, let’s define a registry:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])
(require '[tick.alpha.api :as time])

(def user-profile-service-check-name :services/user-profile)
(def search-service-check-name :services/search)
(def database-check-name :components/database)

(def user-profile-service-check
  (salutem/realtime-check user-profile-service-check-name
    ; produces (salutem/healthy) when evaluated
    (http-endpoint-check-fn
      "https://user-profile.example.com/ping")
    {:timeout (salutem/duration 5 :seconds)}))

(def search-service-check
  (salutem/background-check search-service-check-name
    ; produces (salutem/unhealthy) when evaluated
    (http-endpoint-check-fn
      "https://search.example.com/ping")
    {:time-to-re-evaluation (salutem/duration 5 :seconds)}))

(def database-check
  (salutem/background-check database-check-name
    ; produces (salutem/unhealthy) when evaluated
    (database-check-fn
      {:dbtype   "postgresql"
       :dbname   "service_db"
       :host     "localhost"
       :user     "user"
       :password "secret"})
    {:time-to-re-evaluation (salutem/duration 30 :seconds)}))

(def search-service-result
  (salutem/healthy
    {:latency      "82ms"
     :evaluated-at (t/- (t/now) (t/new-duration 15 :seconds))}))

(def registry
  (-&gt; (salutem/empty-registry)
    (with-check user-profile-service-check)
    (with-check search-service-check)
    (with-check database-check)
    (with-cached-result search-service-check-name search-service-result)))
</code></pre>
<p>Here we have three checks, one realtime check and two background checks. For one of the background checks, we have an outdated cached result.</p>
<p>To resolve each of these checks, use <a href="salutem.core.html#var-resolve-check">salutem.core/resolve-check</a>:</p>
<pre><code class="clojure">(salutem/resolve-check registry user-profile-service-check-name)
;; triggers evaluation since the check is realtime
; =&gt; (salutem/healthy)

(salutem/resolve-check registry search-service-check-name)
;; returns cached result, despite being outdated, since registry doesn't 
;; re-evaluate background checks
; =&gt; (salutem/healthy 
;      {:latency "82ms"
;       :evaluated-at (t/- (t/now) (t/new-duration 15 :seconds))}) 

(salutem/resolve-check registry database-check-name)
;; triggers evaluation since no cached result available
; =&gt; (salutem/unhealthy)
</code></pre>
<p>It’s important to take note that the background check with an outdated result is not re-evaluated as part of resolution. In order to keep the cached result up-to-date, use a <a href="#the-maintenance-pipeline">maintenance pipeline</a>.</p>
<p>To resolve all of the checks in the registry:</p>
<pre><code class="clojure">(salutem/resolve-checks registry)
; =&gt; {user-profile-service-check-name 
;     (salutem/healthy)
;
;     search-service-check-name 
;     (salutem/healthy 
;       {:latency "82ms"
;        :evaluated-at (t/- (t/now) (t/new-duration 15 :seconds))
;     
;     database-check-name
;     (salutem/unhealthy)}
</code></pre>
<p>Since both <a href="salutem.core.html#var-resolve-check">salutem.core/resolve-check</a> and <a href="salutem.core.html#var-resolve-checks">salutem.core/resolve-checks</a> can result in evaluation of checks, they each have an arity that takes a <code>context</code> map to be passed to the check functions if needed.</p>
<h2><a href="#the-maintenance-pipeline" name="the-maintenance-pipeline"></a>The maintenance pipeline</h2>
<p>Whilst the registry alone is sufficient to manage realtime checks, whenever you have background checks, you need a mechanism to ensure that cached results in the registry are kept up-to-date. There are also cases where you may want realtime checks to be evaluated periodically, for example when using those checks to heart beat dependencies or when you are monitoring and alerting on the results of those checks.</p>
<p>To assist in keeping results up-to-date, <code>salutem</code> provides a maintenance pipeline that runs asynchronously, constantly detecting checks in the registry that need to be re-evaluated, evaluating them, updating the registry with their results and storing in the registry store, and notifying interested parties.</p>
<p>The maintenance pipeline, which uses <code>core.async</code> internally, consists of a number of independent processes and channels as depicted in the following diagram:</p>
<img src="images/maintenance-pipeline.png" alt="Maintenance Pipeline" style="width: 100%; max-width: 680px;" />
<p>The responsibility of each process is as follows:</p>
<ul>
  <li><strong>Maintainer</strong>: triggers a refresh attempt for the registry every interval, by  default 200 milliseconds but configurable, by putting a trigger message on to  the trigger channel.</li>
  <li><strong>Refresher</strong>: determines outdated checks based on cached results in the  registry and check re-evaluation times, requesting evaluation of each outdated  check, by putting an evaluation message on the evaluation channel.</li>
  <li><strong>Evaluator</strong>: evaluates checks, timing out if evaluation takes too long,  putting results on to the result channel.</li>
  <li><strong>Updater</strong>: updates the registry with the latest results and replaces the  registry in the registry store.</li>
  <li><strong>Notifier</strong>: calls a set of notification callback functions whenever a new  result is available.</li>
</ul>
<p>You probably won’t need to interact with the individual components of the maintenance pipeline. However, it is useful to know their responsibilities to understand the configuration options. You can also build up alternative pipelines from the components if you need.</p>
<h3><a href="#starting-the-maintenance-pipeline" name="starting-the-maintenance-pipeline"></a>Starting the maintenance pipeline</h3>
<p>To start a maintenance pipeline, do the following:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])

(def registry-store
  (atom
    (-&gt; (health/empty-registry)
      (health/with-check ...)
      (health/with-check ...))))

(def maintenance-pipeline
  (salutem/maintain registry-store))
</code></pre>
<p><a href="salutem.core.html#var-maintain">salutem.core/maintain</a> both instantiates and starts the maintenance pipeline so as soon as it is invoked, the registry store will start receiving updates with check results.</p>
<h3><a href="#stopping-the-maintenance-pipeline" name="stopping-the-maintenance-pipeline"></a>Stopping the maintenance pipeline</h3>
<p>To stop the maintenance pipeline, use <a href="salutem.core.html#var-shutdown">salutem.core/shutdown</a>:</p>
<pre><code class="clojure">(require '[salutem.core :as salutem])

(def maintenance-pipeline
  (salutem/maintain ...))

(salutem/shutdown maintenance-pipeline)
</code></pre>
<h3><a href="#customising-the-maintenance-pipeline" name="customising-the-maintenance-pipeline"></a>Customising the maintenance pipeline</h3>
<p>TODO</p>
<h3><a href="#enabling-logging" name="enabling-logging"></a>Enabling logging</h3>
<p>TODO</p></div></div></div></body></html>