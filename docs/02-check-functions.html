<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Check Functions</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Salutem</span> <span class="project-version">0.1.8</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="01-getting-started.html"><div class="inner"><span>Getting Started</span></div></a></li><li class="depth-1  current"><a href="02-check-functions.html"><div class="inner"><span>Check Functions</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>salutem</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>check-fns</span></div></div></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data-source</span></div></div></li><li class="depth-4"><a href="salutem.check-fns.data-source.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>http-endpoint</span></div></div></li><li class="depth-4"><a href="salutem.check-fns.http-endpoint.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="salutem.core.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="salutem.core.checks.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>checks</span></div></a></li><li class="depth-3 branch"><a href="salutem.core.maintenance.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>maintenance</span></div></a></li><li class="depth-3 branch"><a href="salutem.core.registry.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>registry</span></div></a></li><li class="depth-3 branch"><a href="salutem.core.results.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>results</span></div></a></li><li class="depth-3"><a href="salutem.core.time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>time</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#check-functions" id="check-functions"></a>Check Functions</h1>
<p><code>salutem</code> includes a set of standard check functions for commonly checked things. Currently, <code>salutem</code> includes check functions for:</p>
<ul>
<li>data sources; and</li>
<li>HTTP endpoints.</li>
</ul>
<p>Each check function is packaged as a separate module to <code>salutem.core</code> since they have a number of dependencies that aren’t needed for core <code>salutem</code> operation. See the installation instructions for each for more details.</p>
<h2><a href="#contents" id="contents"></a>Contents</h2>
<ul>
<li><a href="#http-endpoint-check-function">HTTP endpoint check function</a>
<ul>
<li><a href="#hecf-installation">Installation</a></li>
<li><a href="#hecf-usage">Usage</a>
<ul>
<li><a href="#customising-the-request">Customising the request</a></li>
<li><a href="#hecf-customising-timeouts">Customising timeouts</a></li>
<li><a href="#customising-response-success-determination">Customising response success determination</a></li>
<li><a href="#hecf-customising-failure-reason-determination">Customising failure reason determination</a></li>
<li><a href="#hecf-customising-result-generation">Customising result generation</a></li>
<li><a href="#customising-advanced-http-client-options">Customising advanced HTTP client options</a></li>
<li><a href="#hecf-logging-during-execution">Logging during execution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#data-source-check-function">Data source check function</a>
<ul>
<li><a href="#dscf-installation">Installation</a></li>
<li><a href="#dscf-usage">Usage</a>
<ul>
<li><a href="#customising-the-query">Customising the query</a></li>
<li><a href="#dscf-customising-timeouts">Customising timeouts</a></li>
<li><a href="#dscf-customising-failure-reason-determination">Customising failure reason determination</a></li>
<li><a href="#dscf-customising-result-generation">Customising result generation</a></li>
<li><a href="#dscf-logging-during-execution">Logging during execution</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a href="#http-endpoint-check-function" id="http-endpoint-check-function"></a>HTTP endpoint check function</h2>
<p>The HTTP endpoint check function is highly configurable allowing it to support most types of HTTP endpoint. Specifically, the HTTP endpoint check function allows configuration of:</p>
<ul>
<li>the request method, body, headers and query string;</li>
<li>timeouts (connection request, connection and socket);</li>
<li>what constitutes a successful response;</li>
<li>the failure reason determination for any thrown exceptions;</li>
<li>the functions used to generate results; and</li>
<li>many more advanced HTTP client options.</li>
</ul>
<h3><a href="#installation" id="installation"></a><span id="hecf-installation">Installation</span></h3>
<p>To install the check function module, add the following to your <code>project.clj</code> file:</p>
<pre><code class="language-clojure">[io.logicblocks/salutem.check-fns.http-endpoint "0.1.8"]
</code></pre>
<h3><a href="#usage" id="usage"></a><span id="hecf-usage">Usage</span></h3>
<p>To create a check, using an HTTP endpoint check function, of a hypothetical external user profile service:</p>
<pre><code class="language-clojure">(require '[salutem.core :as salutem])
(require '[salutem.check-fns.http-endpoint.core :as salutem-http])

(def user-profile-service-ping-url
  "https://user-profile-service.example.com/ping")

(def user-profile-service-check
  (salutem/background-check
    :services/user-profile
    (salutem-http/http-endpoint-check-fn
      user-profile-service-ping-url)))
</code></pre>
<p>By default, the check function will:</p>
<ul>
<li>be a <code>GET</code> request with no body, request headers or query parameters;</li>
<li>use connection request, connection and socket timeouts of 5 seconds;</li>
<li>treat responses with standard 200 and 300 status codes as healthy and all others as unhealthy; and</li>
<li>include nothing from the request or response in the produced result.</li>
</ul>
<h4><a href="#customising-the-request" id="customising-the-request"></a>Customising the request</h4>
<h5><a href="#method" id="method"></a>Method</h5>
<p>To change the request method for the check, pass the <code>:method</code> option:</p>
<pre><code class="language-clojure">(require '[salutem.check-fns.http-endpoint.core :as salutem-http])

(def check-fn
  (salutem-http/http-endpoint-check-fn
    "https://user-profile-service.example.com/ping"
    {:method :head}))
</code></pre>
<p>The <code>:method</code> option supports <code>:get</code>, <code>:head</code>, <code>:post</code>, <code>:put</code>, <code>:delete</code>, <code>:options</code>, <code>:copy</code>, <code>:move</code> and <code>:patch</code>.</p>
<p>If the <code>:method</code> option is instead a function, it will be called with the context map at execution time in order to obtain the method to use.</p>
<h5><a href="#body" id="body"></a>Body</h5>
<p>To set a body on the request, pass the <code>:body</code> option:</p>
<pre><code class="language-clojure">(require '[salutem.check-fns.http-endpoint.core :as salutem-http])

(def check-fn
  (salutem-http/http-endpoint-check-fn
    "https://user-profile-service.example.com/ping"
    {:method :post
     :body   "{\"status\": \"listening\"}"}))
</code></pre>
<p>The <code>:body</code> option accepts anything supported by <a href="https://github.com/dakrone/clj-http"><code>clj-http</code></a>. Just as for <code>:method</code>, if the <code>:body</code> function is instead a function, it will be called with the context map at execution time in order to obtain the body to use.</p>
<h5><a href="#headers" id="headers"></a>Headers</h5>
<p>To set headers on the request, pass the <code>:headers</code> option:</p>
<pre><code class="language-clojure">(require '[salutem.check-fns.http-endpoint.core :as salutem-http])

(def api-key "ffa55748904f4545de55751e9bd2c5abb45596bd")

(def check-fn
  (salutem-http/http-endpoint-check-fn
    "https://user-profile-service.example.com/ping"
    {:headers {:authorization (str "Bearer " api-key)}}))
</code></pre>
<p>The <code>:headers</code> option accepts anything supported by <a href="https://github.com/dakrone/clj-http"><code>clj-http</code></a> and can be a function of context as with the other request options.</p>
<h5><a href="#query-parameters" id="query-parameters"></a>Query parameters</h5>
<p>To set query parameters on the endpoint URL, pass the <code>:query-params</code> option:</p>
<pre><code class="language-clojure">(require '[salutem.check-fns.http-endpoint.core :as salutem-http])

(def api-key "ffa55748904f4545de55751e9bd2c5abb45596bd")

(def check-fn
  (salutem-http/http-endpoint-check-fn
    "https://user-profile-service.example.com/ping"
    {:query-params {"api_key" api-key}}))
</code></pre>
<p>The <code>:query-params</code> option accepts anything supported by <a href="https://github.com/dakrone/clj-http"><code>clj-http</code></a> and can be a function of context as with the other request options.</p>
<h4><a href="#customising-timeouts" id="customising-timeouts"></a><span id="hecf-customising-timeouts">Customising timeouts</span></h4>
<p>The HTTP check function supports the same three timeouts as <a href="https://github.com/dakrone/clj-http"><code>clj-http</code></a>:</p>
<ul>
<li><code>:connection-request-timeout</code>: the amount of time to wait when obtaining a connection from the connection manager before considering the request failed; useful when using a pooled connection manager.</li>
<li><code>:connection-timeout</code>: the amount of time to wait when establishing an HTTP connection before considering the request failed.</li>
<li><code>:socket-timeout</code>: the amount of time to wait while streaming response data since the last data was received before considering the request failed.</li>
</ul>
<p>To use different durations for each of the timeouts:</p>
<pre><code class="language-clojure">(require '[salutem.core :as salutem])
(require '[salutem.check-fns.http-endpoint.core :as salutem-http])

(def api-key "ffa55748904f4545de55751e9bd2c5abb45596bd")

(def check-fn
  (salutem-http/http-endpoint-check-fn
    "https://user-profile-service.example.com/ping"
    {:connection-request-timeout (salutem/duration 10 :seconds)
     :connection-timeout         (salutem/duration 20 :seconds)
     :socket-timeout             (salutem/duration 500 :millis)}))
</code></pre>
<h4><a href="#customising-response-success-determination" id="customising-response-success-determination"></a>Customising response success determination</h4>
<p>By default, the check function configures <a href="https://github.com/dakrone/clj-http"><code>clj-http</code></a> (the underlying HTTP client) not to throw exceptions when a response has status codes representing a failed request. Instead, it uses a function to determine whether the response represents success and therefore a healthy dependency.</p>
<p>The default function used to determine if the response represents success is <a href="salutem.check-fns.http-endpoint.core.html#var-successful.3F">salutem.check-fns.http-endpoint.core/successful?</a>. To determine success differently, pass the <code>:successful-response-fn</code> as a function of context and the received response:</p>
<pre><code class="language-clojure">(require '[salutem.check-fns.http-endpoint.core :as salutem-http])

(def check-fn
  (salutem-http/http-endpoint-check-fn
    "https://user-profile-service.example.com/ping"
    {:successful-response-fn
     (fn [context response]
       (contains? (:successful-statuses context) (:status response)))}))
</code></pre>
<p>This function is used by the function which generates results for responses (see <a href="#customising-result-generation">below</a>) so in the case that you only need to override the statuses that constitute a healthy vs. unhealthy result, it is sufficient to set <code>:successful-response-fn</code> alone.</p>
<h4><a href="#customising-failure-reason-determination" id="customising-failure-reason-determination"></a><span id="hecf-customising-failure-reason-determination">Customising failure reason determination</span></h4>
<p>When an exception occurs during check execution, <code>salutem</code> results typically include both a <code>:salutem/exception</code> entry containing the exception and a <code>:salutem/reason</code> entry detailing the failure reason. By default, the possible reasons are <code>:timed-out</code> for exceptions indicating timeout and <code>:threw-exception</code> for all other exceptions.</p>
<p>To use a custom function to determine the reason for a failure, pass the <code>:failure-reason-fn</code> option as a function of context and the thrown exception:</p>
<pre><code class="language-clojure">(require '[salutem.core :as salutem])
(require '[salutem.check-fns.http-endpoint.core :as salutem-http])
(import '[my.corp ServiceMaintenanceException])
(import '[org.apache.http.conn ConnectTimeoutException])
(import '[java.net SocketTimeoutException ConnectException])

(def check-fn
  (salutem-http/http-endpoint-check-fn
    "https://user-profile-service.example.com/ping"
    {:failure-reason-fn
     (fn [_ exception]
       (let [exception-class (class exception)
             exception-message (ex-message exception)
             contains-timeout (re-matches #".*Timeout.*" exception-message)]
         (cond
           (isa? exception-class ServiceMaintenanceException)
           :offline-for-maintenance

           (or
             (isa? exception-class ConnectTimeoutException)
             (isa? exception-class SocketTimeoutException)
             (and (isa? exception-class ConnectException) contains-timeout))
           :timed-out

           :else
           :threw-exception)))}))
</code></pre>
<p>Note that the failure reason function is also used to determine the reason to include in log events produced by the check function. See <a href="#hecf-logging-during-execution">Logging during execution</a> for more details on what gets logged by the check function.</p>
<h4><a href="#customising-result-generation" id="customising-result-generation"></a><span id="hecf-customising-result-generation">Customising result generation</span></h4>
<p>Whilst <code>:successful-response-fn</code> and <code>:failure-reason-fn</code> can influence how results are generated for responses and exceptions, sometimes you may want to completely override the result generation. Two options control the generation of results in the check function, one for when a response is received and one for when an exception occurs.</p>
<h5><a href="#response-result-generation" id="response-result-generation"></a>Response result generation</h5>
<p>To change how results are generated when a response is received, pass the <code>:response-result-fn</code> option as a function of context and the received response:</p>
<pre><code class="language-clojure">(require '[salutem.core :as salutem])
(require '[salutem.check-fns.http-endpoint.core :as salutem-http])

(def check-fn
  (salutem-http/http-endpoint-check-fn
    "https://user-profile-service.example.com/ping"
    {:response-result-fn
     (fn [context response]
       (if (= 200 (:status response))
         (salutem/healthy
           (select-keys context [:correlation-id]))
         (salutem/unhealthy
           (merge
             (select-keys context [:correlation-id])
             {:salutem/reason :bad-status-code}))))}))
</code></pre>
<p>The default response result function uses <a href="salutem.check-fns.http-endpoint.core.html#var-successful.3F">salutem.check-fns.http-endpoint.core/successful?</a> to determine if the response should be treated as healthy or unhealthy. If you wish to use the same success semantics and instead only change the content of the result, you can use the same function inside your response result function.</p>
<h5><a href="#exception-result-generation" id="exception-result-generation"></a>Exception result generation</h5>
<p>To change how results are generated when an exception occurs, pass the <code>:exception-result-fn</code> option as a function of context and the thrown exception:</p>
<pre><code class="language-clojure">(require '[salutem.core :as salutem])
(require '[salutem.check-fns.http-endpoint.core :as salutem-http])

(def check-fn
  (salutem-http/http-endpoint-check-fn
    "https://user-profile-service.example.com/ping"
    {:exception-result-fn
     (fn [context exception]
       (let [reason (get (ex-data exception) :reason :threw-exception)
             correlation-id (get context :correlation-id)]
         (salutem/unhealthy
           {:correlation-id    correlation-id
            :salutem/reason    reason
            :salutem/exception exception})))}))
</code></pre>
<p>The default exception result function uses <a href="salutem.check-fns.http-endpoint.core.html#var-failure-reason">salutem.check-fns.http-endpoint.core/failure-reason</a> to determine the <code>:salutem/reason</code> to include in the result. If you wish to use the same failure reason determination and instead only change the content of the result, you can use the same function inside your exception result function.</p>
<h4><a href="#customising-advanced-http-client-options" id="customising-advanced-http-client-options"></a>Customising advanced HTTP client options</h4>
<p>As previously mentioned, under the covers, the HTTP endpoint check function uses <a href="https://github.com/dakrone/clj-http"><code>clj-http</code></a> to perform HTTP requests. The check function exposes an <code>:opts</code> option allowing all other <a href="https://github.com/dakrone/clj-http"><code>clj-http</code></a> options to be overridden, except for:</p>
<ul>
<li>the <code>:async?</code> option, which is always <code>true</code>; and</li>
<li>the timeout options, which are provided directly to the check function.</li>
</ul>
<p>For example, to use a specific connection manager:</p>
<pre><code class="language-clojure">(require '[salutem.check-fns.http-endpoint.core :as salutem-http])
(require '[clj-http.conn-mgr :as conn-mgr])

(def connection-manager
  (conn-mgr/make-reusable-async-conn-manager {}))

(def check-fn
  (salutem-http/http-endpoint-check-fn
    "https://user-profile-service.example.com/ping"
    {:opts {:connection-manager connection-manager}}))
</code></pre>
<h4><a href="#logging-during-execution" id="logging-during-execution"></a><span id="hecf-logging-during-execution">Logging during execution</span></h4>
<p>Just as for <code>salutem.core</code>, if the context map provided to the check function includes a <code>:logger</code> entry with a <a href="https://logicblocks.github.io/cartus/cartus.core.html#var-Logger"><code>cartus.core/Logger</code></a> value, log events will be produced throughout execution.</p>
<p>The events that may be logged during execution are:</p>
<ul>
<li><code>:salutem.check-fns.http-endpoint/check.starting{:url, :method, :body, :headers, :query-params}</code></li>
<li><code>:salutem.check-fns.http-endpoint/check.successful{}</code></li>
<li><code>:salutem.check-fns.http-endpoint/check.failed{:reason, :exception}</code></li>
</ul>
<h2><a href="#data-source-check-function" id="data-source-check-function"></a>Data source check function</h2>
<p>The data source check function is highly configurable and supports any <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/javax/sql/DataSource.html">javax.sql.DataSource</a> .</p>
<h3><a href="#installation" id="installation"></a><span id="dscf-installation">Installation</span></h3>
<p>To install the check function module, add the following to your <code>project.clj</code> file:</p>
<pre><code class="language-clojure">[io.logicblocks/salutem.check-fns.data-source "0.1.8"]
</code></pre>
<h3><a href="#usage" id="usage"></a><span id="dscf-usage">Usage</span></h3>
<p>To create a check, using a data source check function, of a hypothetical H2 database instance:</p>
<pre><code class="language-clojure">(require '[next.jdbc :as jdbc])
(require '[salutem.core :as salutem])
(require '[salutem.check-fns.data-source.core :as salutem-ds])

(def data-source 
  (jdbc/get-datasource 
    {:dbtype "h2mem"
     :dbname "datastore"}))

(def data-source-check
  (salutem/background-check
    :persistence/datastore
    (salutem-ds/data-source-check-fn data-source)))
</code></pre>
<p>By default, the check function will:</p>
<ul>
<li>query the datasource with <code>"SELECT 1 AS up;"</code>;</li>
<li>convert the resulting result set to a map with unqualified kebab-cased keys;</li>
<li>timeout the query after 5 seconds;</li>
<li>treat any query result as an indication of a healthy dependency;</li>
<li>treat any exception as an indication of an unhealthy dependency; and</li>
<li>include the first record in the result set in the response.</li>
</ul>
<h4><a href="#customising-the-query" id="customising-the-query"></a>Customising the query</h4>
<h5><a href="#query-sql-parameters" id="query-sql-parameters"></a>Query SQL parameters</h5>
<p>Whilst the default query is adequate for many databases, it isn’t supported by all. You may also want to execute a query more specific to your context to include additional information in the result.</p>
<p>To configure the query used by the check function, pass the <code>:query-sql-params</code> option:</p>
<pre><code class="language-clojure">(require '[next.jdbc :as jdbc])
(require '[salutem.check-fns.data-source.core :as salutem-ds])

(def data-source 
  (jdbc/get-datasource 
    {:dbtype "h2mem"
     :dbname "datastore"}))

(def check-fn
  (salutem-ds/data-source-check-fn data-source
    {:query-sql-params ["SELECT H2VERSION() AS version FROM DUAL"]}))
</code></pre>
<p>The value for the <code>:query-sql-params</code> option is a SQL parameter vector as defined in <a href="https://github.com/seancorfield/next-jdbc"><code>next.jdbc</code></a>, i.e., it can contain parameters to interpolate into the query string.</p>
<p>The query is executed using <a href="https://github.com/seancorfield/next-jdbc"><code>next.jdbc</code></a>’s <code>execute!</code> function such that the query can result in a result set with many records if required. However, bear in mind that the default <code>:query-results-result-fn</code> includes only the first record in the result set. In order to return a result that utilises all records, you need to override the default result function.</p>
<p>If the value for <code>:query-sql-params</code> is instead a function, it will be called with the context map in order to obtain the SQL parameter vector, allowing for parameters to be supplied to the query at execution time.</p>
<h5><a href="#query-options" id="query-options"></a>Query options</h5>
<p>The check function allows additional query options to be configured, as allowed by <a href="https://github.com/seancorfield/next-jdbc"><code>next.jdbc</code></a>’s <code>execute!</code> function. To configure the query options used when executing the query and interpreting its results, pass the <code>:query-opts</code> option:</p>
<pre><code class="language-clojure">(require '[next.jdbc :as jdbc])
(require '[next.jdbc.result-set :as jdbc-rs])
(require '[salutem.check-fns.data-source.core :as salutem-ds])

(def data-source 
  (jdbc/get-datasource 
    {:dbtype "h2mem"
     :dbname "datastore"}))

(def check-fn
  (salutem-ds/data-source-check-fn data-source
    {:query-opts {:builder-fn jdbc-rs/as-arrays}}))
</code></pre>
<p>By default, <code>:query-opts</code> includes a <code>:builder-fn</code> option which converts the result set to a vector of maps with unqualified kebab-case keys. All options supported by <a href="https://github.com/seancorfield/next-jdbc"><code>next.jdbc</code></a> can be provided, except <code>:timeout</code> which is always provided via the <code>:query-timeout</code> option of the check function.</p>
<p>If the value for <code>:query-opts</code> is instead a function, it will be called with the context map in order to obtain the query options, allowing for options to be supplied to the check function at execution time.</p>
<h4><a href="#customising-timeouts" id="customising-timeouts"></a><span id="dscf-customising-timeouts">Customising timeouts</span></h4>
<p>By default, the check function uses a query timeout of 5 seconds. To use a different duration, pass the <code>:query-timeout</code> option:</p>
<pre><code class="language-clojure">(require '[next.jdbc :as jdbc])
(require '[salutem.core :as salutem])
(require '[salutem.check-fns.data-source.core :as salutem-ds])

(def data-source 
  (jdbc/get-datasource 
    {:dbtype "h2mem"
     :dbname "datastore"}))

(def check-fn
  (salutem-ds/data-source-check-fn data-source
    {:query-timeout (salutem/duration 1 :seconds)}))
</code></pre>
<p>As for other options, if the value for <code>:query-timeout</code> is instead a function, it will be called with the context map in order to obtain the query timeout at execution time.</p>
<p>Other timeouts, such as the connection timeout, login timeout or socket timeout, should be configured on the data source directly. As such, the check function doesn’t provide any facility to change them.</p>
<h4><a href="#customising-failure-reason-determination" id="customising-failure-reason-determination"></a><span id="dscf-customising-failure-reason-determination">Customising failure reason determination</span></h4>
<p>When an exception occurs during check execution, <code>salutem</code> results typically include both a <code>:salutem/exception</code> entry containing the exception and a <code>:salutem/reason</code> entry detailing the failure reason. By default, the possible reasons are <code>:timed-out</code> for exceptions indicating timeout and <code>:threw-exception</code> for all other exceptions.</p>
<p>To use a custom function to determine the reason for a failure, pass the <code>:failure-reason-fn</code> option as a function of context and the thrown exception:</p>
<pre><code class="language-clojure">(require '[next.jdbc :as jdbc])
(require '[salutem.core :as salutem])
(require '[salutem.check-fns.data-source.core :as salutem-ds])
(import '[my.corp MissingPeerException])
(import '[java.sql SQLTimeoutException])

(def data-source
  (jdbc/get-datasource
    {:dbtype "h2mem"
     :dbname "datastore"}))

(def check-fn
  (salutem-ds/data-source-check-fn data-source
    {:failure-reason-fn
     (fn [_ exception]
       (let [exception-class (class exception)]
         (cond
           (isa? exception-class MissingPeerException)
           :cluster-unhealthy

           (isa? exception-class SQLTimeoutException)
           :timed-out

           :else
           :threw-exception)))}))
</code></pre>
<p>Note that the failure reason function is also used to determine the reason to include in log events produced by the check function. See <a href="#dscf-logging-during-execution">Logging during execution</a> for more details on what gets logged by the check function.</p>
<h4><a href="#customising-result-generation" id="customising-result-generation"></a><span id="dscf-customising-result-generation">Customising result generation</span></h4>
<p>Whilst the <code>:query-sql-params</code>, <code>:query-opts</code> and <code>:failure-reason-fn</code> options can influence how results are generated for query results and exceptions, sometimes you may want to completely override the result generation. Two options control the generation of results in the check function, one for when query results are received and one for when an exception occurs.</p>
<h5><a href="#query-results-result-generation" id="query-results-result-generation"></a>Query results result generation</h5>
<p>To change how results are generated when query results are received, pass the <code>:query-results-result-fn</code> option as a function of context and the received query results:</p>
<pre><code class="language-clojure">(require '[next.jdbc :as jdbc])
(require '[salutem.core :as salutem])
(require '[salutem.check-fns.data-source.core :as salutem-ds])

(def data-source
  (jdbc/get-datasource
    {:dbtype "h2mem"
     :dbname "datastore"}))

(def check-fn
  (salutem-ds/data-source-check-fn data-source
    {:query-sql-params ["SELECT H2VERSION() FROM DUAL;"]
     :query-results-result-fn
     (fn [context results]
       (let [version (:h2version (first results))]
         (if (= version (:required-database-version context))
           (salutem/healthy {:version version})
           (salutem/unhealthy 
             {:salutem/reason :incorrect-database-version
              :version version}))))}))
</code></pre>
<h5><a href="#exception-result-generation" id="exception-result-generation"></a>Exception result generation</h5>
<p>To change how results are generated when an exception occurs, pass the <code>:exception-result-fn</code> option as a function of context and the thrown exception:</p>
<pre><code class="language-clojure">(require '[next.jdbc :as jdbc])
(require '[salutem.core :as salutem])
(require '[salutem.check-fns.data-source.core :as salutem-ds])

(def data-source
  (jdbc/get-datasource
    {:dbtype "h2mem"
     :dbname "datastore"}))

(def check-fn
  (salutem-ds/data-source-check-fn data-source
    {:exception-result-fn
     (fn [context exception]
       (let [reason (get (ex-data exception) :reason :threw-exception)
             correlation-id (get context :correlation-id)]
         (salutem/unhealthy
           {:correlation-id    correlation-id
            :salutem/reason    reason
            :salutem/exception exception})))}))
</code></pre>
<p>The default exception result function uses <a href="salutem.check-fns.data-source.core.html#var-failure-reason">salutem.check-fns.data-source.core/failure-reason</a> to determine the <code>:salutem/reason</code> to include in the result. If you wish to use the same failure reason determination and instead only change the content of the result, you can use the same function inside your exception result function.</p>
<h4><a href="#logging-during-execution" id="logging-during-execution"></a><span id="dscf-logging-during-execution">Logging during execution</span></h4>
<p>Just as for <code>salutem.core</code>, if the context map provided to the check function includes a <code>:logger</code> entry with a <a href="https://logicblocks.github.io/cartus/cartus.core.html#var-Logger"><code>cartus.core/Logger</code></a> value, log events will be produced throughout execution.</p>
<p>The events that may be logged during execution are:</p>
<ul>
<li><code>:salutem.check-fns.data-source/check.starting{:query-sql-params}</code></li>
<li><code>:salutem.check-fns.data-source/check.successful{}</code></li>
<li><code>:salutem.check-fns.data-source/check.failed{:reason,:exception}</code></li>
</ul>
</div></div></div></body></html>